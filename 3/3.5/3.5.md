  # Módulo de blog
  
  **Decision**:  Selección de Herramienta para la Gestión del Módulo de Blog

  **Título**: Elección de la herramienta para desarrollar el módulo de blog.

  **Contexto**: El proyecto busca crear un módulo de blog en el que los usuarios puedan compartir contenido multimedia, interactuar en hilos de conversación, y organizar publicaciones con hashtags y categorías. El volumen de usuarios esperado es alto, dado que el blog es parte de una plataforma de turismo en crecimiento. Se necesita una solución que permita gestionar eficientemente el contenido multimedia, hashtags, categorías, y comentarios, así como soportar la interacción en tiempo real entre los usuarios.

  **Alternativas**: 

  *Desarrollo a Medida (Full-stack)*: Desarrollo personalizado utilizando una combinación de React para el frontend y Node.js con una base de datos NoSQL (MongoDB) para el backend.

  *Uso de una Plataforma CMS (WordPress)*: Utilizar WordPress como base, extendido con plugins personalizados para gestionar las publicaciones, hashtags y categorías.
  
  **Criterios de Elección**: 

  Velocidad de desarrollo: Es importante entregar el módulo en un plazo corto, ya que la plataforma necesita escalar pronto.
  
  Flexibilidad y personalización: La posibilidad de ajustar el sistema según crezcan las necesidades de la plataforma.
  
  Escalabilidad: La solución debe soportar el aumento de usuarios y de contenido multimedia sin afectar el rendimiento.
  
  Costos de desarrollo y mantenimiento: Mantener un balance entre la inversión inicial y los costos futuros.
  
  Seguridad: Garantizar la protección de datos de los usuarios, en cumplimiento con normativas de privacidad.
  
  **Decisión**:
  Se elige la alternativa de Desarrollo a Medida utilizando React y Node.js.

  **Sustento**: 
  El desarrollo a medida ofrece la flexibilidad necesaria para personalizar completamente las funcionalidades del blog, como la gestión de hashtags populares y categorías. Aunque requiere más tiempo de desarrollo inicial, permite un control completo sobre la escalabilidad, lo cual es crucial a medida que crezca la plataforma. Node.js ofrece un manejo eficiente de solicitudes concurrentes, lo que mejora la interacción en tiempo real entre los usuarios, mientras que React permite un frontend dinámico y amigable.


# ADR - Módulo de Itinerario Personalizable

## Decisión 1: Elección de Tecnología para el Frontend

### Título:  
Elección entre React.js vs Vue.js para el desarrollo del módulo de Itinerario Personalizable.

### Contexto:  
El módulo debe permitir a los usuarios crear y personalizar itinerarios de viajes, por lo que la interfaz debe ser intuitiva, ágil y altamente interactiva. Los usuarios deben poder agregar, editar y visualizar actividades de manera eficiente, incluyendo funciones de arrastrar y soltar para reordenar actividades. Es necesario que la interfaz sea rápida y receptiva.  
El equipo cuenta con experiencia moderada en tecnologías frontend, y se ha considerado React.js y Vue.js como las principales alternativas. Se valora la facilidad de mantenimiento, la curva de aprendizaje y el rendimiento.

### Alternativas:
1. **React.js**
   - Ofrece un ecosistema robusto y una gran comunidad de soporte.
   - Facilita la creación de interfaces interactivas y eficientes gracias a su DOM virtual.
   - La curva de aprendizaje es empinada, pero una vez dominado, ofrece mayor control sobre el flujo de la aplicación.
2. **Vue.js**
   - Es fácil de aprender y tiene una curva de aprendizaje más suave.
   - La integración en proyectos existentes es sencilla, lo cual es útil si se requieren futuras expansiones o cambios.
   - También ofrece rendimiento alto y una comunidad creciente.

### Criterios de Elección:
- **Interactividad y rendimiento**: Se necesita una UI ágil que soporte funcionalidades como la creación y edición de itinerarios en tiempo real.
- **Curva de aprendizaje**: Dado que el equipo no tiene experiencia avanzada en ninguna de las dos tecnologías, se valora la facilidad de adopción.
- **Ecosistema y soporte**: Se busca una tecnología con un ecosistema amplio que permita escalar el proyecto fácilmente y solucionar problemas rápidamente.

### Decisión:  
Se elige **React.js**.

### Sustento:  
Aunque Vue.js tiene una curva de aprendizaje más suave, se elige React.js debido a la necesidad de manejar una interfaz altamente interactiva y personalizable. React.js tiene un ecosistema maduro y es conocido por su rendimiento óptimo en aplicaciones con muchas interacciones en la UI, como el reordenamiento de actividades en itinerarios. Además, la comunidad más grande de React.js ofrece más soporte y recursos para asegurar el éxito del proyecto a largo plazo.

---

## Decisión 2: Elección de Base de Datos para la Gestión de Itinerarios

### Título:  
Elección entre Base de Datos Relacional vs Documental para el almacenamiento de itinerarios personalizados.

### Contexto:  
El módulo de itinerarios personalizables requiere almacenar datos estructurados, como la fecha de inicio y fin del itinerario, las actividades programadas (con horarios y ubicaciones), y los favoritos del usuario. Cada itinerario puede variar en tamaño y complejidad, con algunos itinerarios siendo simples y otros muy extensos. Además, el equipo tiene experiencia con bases de datos relacionales como PostgreSQL, mientras que no tiene conocimientos previos en bases de datos documentales como MongoDB.

### Alternativas:
1. **Base de Datos Relacional (PostgreSQL)**  
   - Ofrece integridad de datos y manejo eficiente de relaciones entre las distintas entidades, como usuarios, lugares turísticos y actividades.
   - Ideal para consultas estructuradas, especialmente cuando se requiere consistencia y validación de datos.
   - El equipo ya tiene experiencia con esta tecnología, lo que reduce la curva de aprendizaje y facilita el desarrollo.
   
2. **Base de Datos Documental (MongoDB)**  
   - Proporciona flexibilidad en la definición de esquemas, ideal para manejar itinerarios que pueden cambiar de forma frecuente.
   - Escalabilidad horizontal, adecuada para almacenar grandes cantidades de datos, como los itinerarios personalizados de muchos usuarios.
   - Requiere que el equipo adquiera nuevos conocimientos, lo que podría ralentizar el desarrollo inicial.

### Criterios de Elección:
- **Conocimiento del equipo**: El equipo ya tiene experiencia con PostgreSQL, lo cual reduce el tiempo de implementación y facilita el mantenimiento.
- **Integridad de datos**: Los itinerarios requieren un nivel de consistencia y validación que se maneja mejor con un modelo relacional.
- **Escalabilidad y flexibilidad**: Aunque una base de datos documental ofrece mayor flexibilidad, el equipo debe poder implementar y mantener el sistema con las herramientas que ya domina.

### Decisión:  
Se elige **PostgreSQL**.

### Sustento:  
A pesar de que MongoDB ofrece una mayor flexibilidad en la gestión de esquemas, se opta por PostgreSQL debido al conocimiento previo del equipo y su experiencia en el manejo de bases de datos relacionales. Esto asegura un desarrollo más ágil, sin la necesidad de invertir tiempo en aprender nuevas tecnologías. PostgreSQL también es capaz de manejar las relaciones complejas entre usuarios, lugares y actividades de forma eficiente, lo que lo convierte en una opción viable para las necesidades del proyecto. La familiaridad del equipo con PostgreSQL garantiza que el desarrollo sea más fluido y que los recursos se aprovechen de manera óptima.


## Módulo de reseñas y comentarios

### Decisión 1
**Título:**   
- Elección de una base de datos relacional o documental
  
**Contexto:**   
- Los reportes de reseñas y comentarios maliciosos presentan una estructura de datos poco compleja y menos estructurada. La base de datos debe almacenar los reportes, asociarlos a las reseñas y a los usuarios, además de permitir consultas y filtrados rápidos para la moderación de los administradores.

**Alternativas:**   
1. Modelo Relacional (PostgreSQL)  
   - Permite relaciones complejas entre los las reseñas y usuarios a nivel de reporte. 
   - Es fácil agregar, actualizar o borrar tablas, relaciones y hacer otros cambios a los datos.
   - Es fácil ejecutar consultas complejas con SQL.
   - Normalización de los datos para reducir la redundancia.
2. Modelo deocumental (MongoBD)  
   - Permite el fácil manejo de datos no estructurados.
   - Facilidad para manejar gran cantidad de información y datos de forma rápida.
   - Poseen un lenguaje de consulta fácil e intuitivo
   - Podría almacenar los reportes como documentos JSON independientes.
  
**Criterios de Elección:**  
- **Flexibilidad de los datos**: El sistema de reportes puede necesitar ajustes en la estructura de los datos por cambios en el flujo de reportes.
- **Escalabilidad de los datos**: Manejar un número creciente de reportes conforme la plataforma crece y la probabilidad de que se manifiesten mayor cantidad de reportes incremente.
- **Consultas a los datos**: Realizar consultas rápidas de la información.
- **Costos de infraestructura**: Se requiere de un bajo costo al ser una funcionaliad de los reportes bastante sencilla pero importante de mantener.

**Decisión:**  
- MongoDB

**Sustento:**
- Este tipo de modelo es más flexible para manejar datos no estructurados, como diferentes tipos de reportes o información variable en el tiempo sin la necesidad de mantener una estructura rígida. Además, el modelo documental permitirá un escalado horizontal más sencillo para manejar grandes volúmenes de datos sin complicaciones de relaciones entre entidades. Finalmente, tienden a ser más rápidos en operaciones de escritura, lo cual es una ventaja si el sistema de reportes requiere procesar muchas entradas en tiempo real sin tener que manejar relaciones complejas entre entidades con la ventaja de ser una solución menos costosa a niveles de infraestructura y recursos necesarios.


### Decisión 2
*Título:*   
- Elección entre algoritmos propios vs APIs para detección de contenido inapropiado en textos
  
*Contexto:*  
- El sistema de Turi necesita detectar contenido inapropiado en los textos que se intentan publicar en reseñas y comentarios, garantizando que la detección sea rápida y sin afectar la experiencia del usuario. El objetivo es identificar lenguaje ofensivo, spam o cualquier otro contenido que infrinja las políticas de la plataforma.

*Alternativas:*   
1. Algoritmos propios:
   - Desarrollar e implementar un sistema propio de clasificación y análisis de texto usando técnicas como procesamiento de lenguaje natural (NLP) y listas negras. La ventaja recae en no depende de terceros y la alta capacidad de ajuste a las necesidades específicas de la plataforma.
2. APIs externas:
   - Integrar servicios de detección de contenido inapropiado mediante APIs externas como Google Cloud Natural Language o AWS Comprehend, las cuales permiiten una implementación rápida y escalable, reduciendo el esfuerzo de desarrollo de un sistema propio y de su mantenimiento.
  
*Criterios de Elección:*  
- **Velocidad y rendimiento:** El procesamiento debe ser casi inmediato, debe ser casi imperceptible para que los usuarios.
- **Escalabilidad**: Manejar un creciente número de textos y usuarios sin perder eficiencia.
- **Control y personalización**: Adaptar el sistema de detección a las necesidades específicas de Turi.
- **Costos**: Considerar los costos no solo de implementación sino a largo plazo y todo lo que conlleva.
- **Precisión**: Utilizar una solución con alta precisión en la detección de contenido.
- **Detección de textos en diferentes idiomas**: Detectar palabras que vulneren las políticas de la plataforma de diferentes idiomas, no solo el español.

*Decisión:*  
- APIs externas

*Sustento:*
- Son soluciones preexistentes que tienen una alta escalabilidad probada, además de tener una capacidad de integración rápida. Los tiempos de procesamiento son rápido, asegurando una detección eficiente sin afectar la experiencia del usuario. Las APIs sugeridas pueden detectar palabras que incumplen las políticas de la plataforma donde se implemente, lo que requiere una previa configuración. Adicionalmente, en términos de categorización de palabras y su precisión, estas soluciones pueden clasificar mediante confidence score y siguiendo categorías como: acoso sexual, _hate speechs_, violencia y amenazas, abuso, palabras vulgares como insultos o gráficas (AWS Comprehend). Finalmente, en cuanto a costos es mejor la implementación de una API preexistente para ahorrar costos de implementación del sistema y del mantenimiento a futuro, lo que requeriría de desarrolladores y de tiempo.
